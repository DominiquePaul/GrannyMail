import json

import httpx
from telegram import Update
from telegram.ext._contexttypes import ContextTypes

import grannymail.db.classes as dbc
import grannymail.db.supaclient as supaclient
from grannymail.utils import message_utils

dbclient = supaclient.SupabaseClient()


class TelegramHandler:
    def __init__(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
    ):
        self.update = update
        self.context = context

    def _get_message_type(self, message) -> tuple[str, str | None]:
        assert message is not None, "No message found"
        if message.voice:
            return "voice", message.voice.mime_type
        if message.photo:
            return "image", message.photo[-1].mime_type
        elif message.document:
            return "file", message.document.mime_type
        elif message.text:
            return "text", None
        else:
            return "unknown", None

    async def _download_file(
        self, file_id: str, context: ContextTypes.DEFAULT_TYPE
    ) -> bytes:
        file = await context.bot.getFile(file_id)
        async with httpx.AsyncClient() as client:
            response = await client.get(file.file_path)  # type: ignore
        return response.content

    async def _download_media(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE, media_type: str
    ) -> list[bytes]:
        media_bytes_list = []
        assert update.message is not None, "No message found"
        if media_type == "image" and update.message.photo:
            for photo in update.message.photo:
                file_id = photo.file_id
                media_bytes = await self._download_file(file_id, context)
                media_bytes_list.append(media_bytes)
        return media_bytes_list

    async def parse_message(self):
        if self.update.message is None:
            raise ValueError("No message found")
        assert self.update.message.from_user is not None, "'from_user' not found"

        telegram_id: str = self.update.message.from_user.username  # type: ignore
        try:
            user = dbclient.get_user(dbc.User(telegram_id=telegram_id))
        except supaclient.NoEntryFoundError:
            first_name: str = self.update.message.from_user.first_name  # type: ignore
            last_name: str = self.update.message.from_user.last_name  # type: ignore
            user = dbclient.add_user(
                dbc.User(
                    telegram_id=telegram_id,
                    first_name=first_name,
                    last_name=last_name,
                    email="anonymous@user.com",
                )
            )

        message_type, attachment_mime_type = self._get_message_type(self.update.message)
        data = {
            "user_id": user.user_id,
            "sent_by": "user",
            "message_id": None,  # Placeholder, will be generated by the DB
            "timestamp": str(self.update.message.date),
            "attachment_mime_type": attachment_mime_type,
            "message_type": message_type,
            "tg_id": self.update.message.from_user["username"],
            "tg_chat_id": self.update.effective_chat.id,  # type: ignore
            "tg_message_id": self.update.message.message_id,
        }

        # Handle different message types
        if message_type == "voice":
            voice_bytes = await self._download_file(
                self.update.message.voice.file_id, self.context  # type: ignore
            )
            transcript = message_utils.transcribe_voice_memo(voice_bytes)
            data.update(
                {
                    "memo_duration": self.update.message.voice.duration,  # type: ignore
                    "transcript": transcript,
                }
            )
        elif message_type == "file":
            file_bytes = await self._download_file(
                self.update.message.document.file_id, self.context  # type: ignore
            )
            # Process file_bytes as needed
        elif message_type == "image":
            images_bytes_list = await self._download_media(
                self.update, self.context, "image"
            )
            # Process images_bytes_list as needed
        elif message_type == "text":
            command, message_body = message_utils.parse_command(
                self.update.message.text  # type: ignore
            )
            data.update(
                {
                    "message_body": message_body,
                    "command": command,
                }
            )

        # Handle callback query
        if self.update.callback_query is not None:
            query = self.update.callback_query
            await query.answer()
            referenced_message_id = json.loads(query.data)["mid"]  # type: ignore
            data["referenced_message_id"] = referenced_message_id

        # create message in db
        message = dbc.TelegramMessage(**data)
        message = dbclient.add_message(message)
        # if voice memo was included then upload it now. Requires message_id for registration
        if data["message_type"] == "voice":
            dbclient.register_voice_message(voice_bytes, message)  # type: ignore

        self.message = message

    async def send_message(self, message_body):
        await self.context.bot.send_message(
            chat_id=self.update.effective_chat.id, text=message_body  # type: ignore
        )
